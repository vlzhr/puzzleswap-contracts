{-# STDLIB_VERSION 6 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}
{-# IMPORT artifacts/mainnet.ride #-}


let li = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38"]

let hours = 24
let minutes = 60

func tryGetInteger (key:String) = match getInteger(this, key) {
    case b: Int => 
        b
    case _ => 
        0
}

func tryGetString (key:String) = match getString(this, key) {
    case b: String => 
        b
    case _ => 
        ""
}

func getAssetString (assetId:ByteVector|Unit) = match assetId {
    case b: ByteVector => 
        toBase58String(b)
    case _ => 
        "WAVES"
}

func getAssetBytes (assetIdStr:String) = if ((assetIdStr == "WAVES"))
    then unit
    else fromBase58String(assetIdStr)

func payBoostingResult (boostingId:String) = {
    let lastHeight = tryGetInteger((("boosting_" + boostingId) + "_lastHeight"))
    let finishHeight = tryGetInteger((("boosting_" + boostingId) + "_finishHeight"))
    if (if ((lastHeight != 0))
        then (finishHeight > lastHeight)
        else false)
        then {
            let blockReward = tryGetInteger((("boosting_" + boostingId) + "_totalAmount")) / ((tryGetInteger(("boosting_" + boostingId) + "_days") * hours * minutes))
            let toPay = fraction((min([finishHeight, height]) - lastHeight), blockReward, 1)

            let getFinishedPoolId = tryGetString((("boosting_" + boostingId) + "_poolId"))
            let getPoolBoostings =  tryGetString(("pool_" + getFinishedPoolId) + "_boostings")
            let sizeStr = size(getPoolBoostings)
            let findIndex = value(indexOf(getPoolBoostings, boostingId))
            let modifierLeft = if findIndex == 0 then 0 else 1
            let modifierRight = if findIndex == 0 then 2 else 1
            let leftStr = take(getPoolBoostings, sizeStr - (sizeStr - findIndex + modifierLeft))
            let rightStr = takeRight(getPoolBoostings, sizeStr - (findIndex + modifierRight))
            let openBoostingsIds = leftStr + rightStr            
            [
            IntegerEntry((("boosting_" + boostingId) + "_lastHeight"), height), 

            ScriptTransfer(addressFromStringValue(tryGetString((("boosting_" + boostingId) + "_poolId"))), 
              toPay, 
              getAssetBytes(tryGetString((("boosting_" + boostingId) + "_assetId")))),

            StringEntry((("pool_" + getFinishedPoolId) + "_boostings"),
              if (height < finishHeight) 
              then tryGetString((("pool_" + getFinishedPoolId) + "_boostings")) 
              else openBoostingsIds)
            ]
            }
        else nil
    }

let keyEnded = "list ended boostingIds"
let listEnded = split_4C(dropRight(tryGetString(keyEnded), 1), ",")
let keyOngoing = "list ongoing boosts boostingIds"

func endedBoostingIds (boostingId:String) = {
    let lastHeight = tryGetInteger((("boosting_" + boostingId) + "_lastHeight"))
    let finishHeight = tryGetInteger((("boosting_" + boostingId) + "_finishHeight"))
    if finishHeight <= lastHeight then 
    [StringEntry(keyEnded, (tryGetString(((keyEnded)) + boostingId) + ","))]
        else [StringEntry(keyOngoing, ((tryGetString(keyOngoing) + boostingId) + ","))]
    }

@Callable(i)
func addBoosting (poolId:String, days:Int) = 
if (days < 1) then throw("amount of days has to be between 1 and 365") else if (days> 365) then throw("amount of days has to be between 1 and 365") else
#protected mode, to comment out after succesfull live testing 
if (false) then throw("under maintenance until further notice") else # i.caller != Address(base58'3P8qVX189qpoTJZQQQdKS9endHK5sxWsvrd'))

{
    let fullAmount = i.payments[0].amount
    if fullAmount / days < 1440 then throw((("boosting amount too small, minimum is " + toString((1440 * days)) + " of the smallest unit of payment asset"))) else
        let assetId = getAssetString(i.payments[0].assetId)
            let keyPoolBoostings = "pool_" + poolId + "_boostings"
            let listPoolBoostings = split_4C(dropRight(tryGetString(keyPoolBoostings), 1), ",")
            strict entry = if size(listPoolBoostings) > 4 then throw("max 4 boosts per pool") else invoke(this, "entryEnded", [], [])
    let listOngoing = split_4C(dropRight(tryGetString(keyOngoing), 1), ",")
    let boostingId = if size(listOngoing) > 38 then throw("wait till other boosts are finished") else getElement(listEnded, 0)
    if ((addressFromString(poolId) == unit))
        then throw("incorrect pool address")
        else 
        [
        IntegerEntry((("boosting_" + boostingId) + "_days"), days), 
        IntegerEntry((("boosting_" + boostingId) + "_totalAmount"), fullAmount), 
        IntegerEntry((("boosting_" + boostingId) + "_dailyAmount"), (fullAmount / days)), 
        IntegerEntry((("boosting_" + boostingId) + "_startHeight"), height), 
        IntegerEntry((("boosting_" + boostingId) + "_finishHeight"), (height + ((days * hours) * minutes))), 
        IntegerEntry((("boosting_" + boostingId) + "_finishTimestamp"), (lastBlock.timestamp + ((((days * hours) * minutes) * 60) * 1000))), 
        IntegerEntry((("boosting_" + boostingId) + "_lastHeight"), height), 
        StringEntry((("boosting_" + boostingId) + "_assetId"), assetId), 
        StringEntry((("boosting_" + boostingId) + "_owner"), toString(i.caller)), 
        StringEntry((("boosting_" + boostingId) + "_poolId"), poolId), 
        StringEntry((("pool_" + poolId) + "_boostings"), ((tryGetString((("pool_" + poolId) + "_boostings")) + boostingId) + ","))
        ]
    }

@Callable(i)
func payBoosting (boostingId:String) = payBoostingResult(boostingId)

@Callable(i)
func payBoostings () = {
    func f (accum:Int, next:String) = {
        let in = invoke(this, "payBoosting", [next], nil)
        if ((in == in))
            then in
            else throw("Strict value is not equal to itself.")
        }
    let payments = { 
        FOLD<38>(li, 0, f)
        }
    if ((payments == payments))
        then nil
        else throw("Strict value is not equal to itself.")
    }

@Callable(i)
func endedBoostings (boostingId:String) = endedBoostingIds(boostingId)

@Callable(i)
func entryEnded () = {
    func f (accum:Int, next:String) = {
        let in = invoke(this, "endedBoostings", [next], nil)
        if ((in == in))
            then in
            else throw("Strict value is not equal to itself.")
        }
    let end = { 
        FOLD<38>(li, 0, f)
        }
    if ((end == end))
        then []
        else throw("Strict value is not equal to itself.")
    }
